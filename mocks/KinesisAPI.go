// Code generated by mockery v2.40.3. DO NOT EDIT.

package mocks

import (
	context "context"

	kinesis "github.com/aws/aws-sdk-go-v2/service/kinesis"

	mock "github.com/stretchr/testify/mock"
)

// KinesisAPI is an autogenerated mock type for the KinesisAPI type
type KinesisAPI struct {
	mock.Mock
}

type KinesisAPI_Expecter struct {
	mock *mock.Mock
}

func (_m *KinesisAPI) EXPECT() *KinesisAPI_Expecter {
	return &KinesisAPI_Expecter{mock: &_m.Mock}
}

// CreateStream provides a mock function with given fields: ctx, params, optFns
func (_m *KinesisAPI) CreateStream(ctx context.Context, params *kinesis.CreateStreamInput, optFns ...func(*kinesis.Options)) (*kinesis.CreateStreamOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateStream")
	}

	var r0 *kinesis.CreateStreamOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.CreateStreamInput, ...func(*kinesis.Options)) (*kinesis.CreateStreamOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.CreateStreamInput, ...func(*kinesis.Options)) *kinesis.CreateStreamOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesis.CreateStreamOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesis.CreateStreamInput, ...func(*kinesis.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KinesisAPI_CreateStream_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateStream'
type KinesisAPI_CreateStream_Call struct {
	*mock.Call
}

// CreateStream is a helper method to define mock.On call
//   - ctx context.Context
//   - params *kinesis.CreateStreamInput
//   - optFns ...func(*kinesis.Options)
func (_e *KinesisAPI_Expecter) CreateStream(ctx interface{}, params interface{}, optFns ...interface{}) *KinesisAPI_CreateStream_Call {
	return &KinesisAPI_CreateStream_Call{Call: _e.mock.On("CreateStream",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *KinesisAPI_CreateStream_Call) Run(run func(ctx context.Context, params *kinesis.CreateStreamInput, optFns ...func(*kinesis.Options))) *KinesisAPI_CreateStream_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*kinesis.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*kinesis.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*kinesis.CreateStreamInput), variadicArgs...)
	})
	return _c
}

func (_c *KinesisAPI_CreateStream_Call) Return(_a0 *kinesis.CreateStreamOutput, _a1 error) *KinesisAPI_CreateStream_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *KinesisAPI_CreateStream_Call) RunAndReturn(run func(context.Context, *kinesis.CreateStreamInput, ...func(*kinesis.Options)) (*kinesis.CreateStreamOutput, error)) *KinesisAPI_CreateStream_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteStream provides a mock function with given fields: ctx, params, optFns
func (_m *KinesisAPI) DeleteStream(ctx context.Context, params *kinesis.DeleteStreamInput, optFns ...func(*kinesis.Options)) (*kinesis.DeleteStreamOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteStream")
	}

	var r0 *kinesis.DeleteStreamOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.DeleteStreamInput, ...func(*kinesis.Options)) (*kinesis.DeleteStreamOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.DeleteStreamInput, ...func(*kinesis.Options)) *kinesis.DeleteStreamOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesis.DeleteStreamOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesis.DeleteStreamInput, ...func(*kinesis.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KinesisAPI_DeleteStream_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteStream'
type KinesisAPI_DeleteStream_Call struct {
	*mock.Call
}

// DeleteStream is a helper method to define mock.On call
//   - ctx context.Context
//   - params *kinesis.DeleteStreamInput
//   - optFns ...func(*kinesis.Options)
func (_e *KinesisAPI_Expecter) DeleteStream(ctx interface{}, params interface{}, optFns ...interface{}) *KinesisAPI_DeleteStream_Call {
	return &KinesisAPI_DeleteStream_Call{Call: _e.mock.On("DeleteStream",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *KinesisAPI_DeleteStream_Call) Run(run func(ctx context.Context, params *kinesis.DeleteStreamInput, optFns ...func(*kinesis.Options))) *KinesisAPI_DeleteStream_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*kinesis.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*kinesis.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*kinesis.DeleteStreamInput), variadicArgs...)
	})
	return _c
}

func (_c *KinesisAPI_DeleteStream_Call) Return(_a0 *kinesis.DeleteStreamOutput, _a1 error) *KinesisAPI_DeleteStream_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *KinesisAPI_DeleteStream_Call) RunAndReturn(run func(context.Context, *kinesis.DeleteStreamInput, ...func(*kinesis.Options)) (*kinesis.DeleteStreamOutput, error)) *KinesisAPI_DeleteStream_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeStream provides a mock function with given fields: ctx, params, optFns
func (_m *KinesisAPI) DescribeStream(ctx context.Context, params *kinesis.DescribeStreamInput, optFns ...func(*kinesis.Options)) (*kinesis.DescribeStreamOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeStream")
	}

	var r0 *kinesis.DescribeStreamOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.DescribeStreamInput, ...func(*kinesis.Options)) (*kinesis.DescribeStreamOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.DescribeStreamInput, ...func(*kinesis.Options)) *kinesis.DescribeStreamOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesis.DescribeStreamOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesis.DescribeStreamInput, ...func(*kinesis.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KinesisAPI_DescribeStream_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeStream'
type KinesisAPI_DescribeStream_Call struct {
	*mock.Call
}

// DescribeStream is a helper method to define mock.On call
//   - ctx context.Context
//   - params *kinesis.DescribeStreamInput
//   - optFns ...func(*kinesis.Options)
func (_e *KinesisAPI_Expecter) DescribeStream(ctx interface{}, params interface{}, optFns ...interface{}) *KinesisAPI_DescribeStream_Call {
	return &KinesisAPI_DescribeStream_Call{Call: _e.mock.On("DescribeStream",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *KinesisAPI_DescribeStream_Call) Run(run func(ctx context.Context, params *kinesis.DescribeStreamInput, optFns ...func(*kinesis.Options))) *KinesisAPI_DescribeStream_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*kinesis.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*kinesis.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*kinesis.DescribeStreamInput), variadicArgs...)
	})
	return _c
}

func (_c *KinesisAPI_DescribeStream_Call) Return(_a0 *kinesis.DescribeStreamOutput, _a1 error) *KinesisAPI_DescribeStream_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *KinesisAPI_DescribeStream_Call) RunAndReturn(run func(context.Context, *kinesis.DescribeStreamInput, ...func(*kinesis.Options)) (*kinesis.DescribeStreamOutput, error)) *KinesisAPI_DescribeStream_Call {
	_c.Call.Return(run)
	return _c
}

// GetRecords provides a mock function with given fields: ctx, params, optFns
func (_m *KinesisAPI) GetRecords(ctx context.Context, params *kinesis.GetRecordsInput, optFns ...func(*kinesis.Options)) (*kinesis.GetRecordsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetRecords")
	}

	var r0 *kinesis.GetRecordsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.GetRecordsInput, ...func(*kinesis.Options)) (*kinesis.GetRecordsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.GetRecordsInput, ...func(*kinesis.Options)) *kinesis.GetRecordsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesis.GetRecordsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesis.GetRecordsInput, ...func(*kinesis.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KinesisAPI_GetRecords_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRecords'
type KinesisAPI_GetRecords_Call struct {
	*mock.Call
}

// GetRecords is a helper method to define mock.On call
//   - ctx context.Context
//   - params *kinesis.GetRecordsInput
//   - optFns ...func(*kinesis.Options)
func (_e *KinesisAPI_Expecter) GetRecords(ctx interface{}, params interface{}, optFns ...interface{}) *KinesisAPI_GetRecords_Call {
	return &KinesisAPI_GetRecords_Call{Call: _e.mock.On("GetRecords",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *KinesisAPI_GetRecords_Call) Run(run func(ctx context.Context, params *kinesis.GetRecordsInput, optFns ...func(*kinesis.Options))) *KinesisAPI_GetRecords_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*kinesis.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*kinesis.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*kinesis.GetRecordsInput), variadicArgs...)
	})
	return _c
}

func (_c *KinesisAPI_GetRecords_Call) Return(_a0 *kinesis.GetRecordsOutput, _a1 error) *KinesisAPI_GetRecords_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *KinesisAPI_GetRecords_Call) RunAndReturn(run func(context.Context, *kinesis.GetRecordsInput, ...func(*kinesis.Options)) (*kinesis.GetRecordsOutput, error)) *KinesisAPI_GetRecords_Call {
	_c.Call.Return(run)
	return _c
}

// GetShardIterator provides a mock function with given fields: ctx, params, optFns
func (_m *KinesisAPI) GetShardIterator(ctx context.Context, params *kinesis.GetShardIteratorInput, optFns ...func(*kinesis.Options)) (*kinesis.GetShardIteratorOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetShardIterator")
	}

	var r0 *kinesis.GetShardIteratorOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.GetShardIteratorInput, ...func(*kinesis.Options)) (*kinesis.GetShardIteratorOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.GetShardIteratorInput, ...func(*kinesis.Options)) *kinesis.GetShardIteratorOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesis.GetShardIteratorOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesis.GetShardIteratorInput, ...func(*kinesis.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KinesisAPI_GetShardIterator_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetShardIterator'
type KinesisAPI_GetShardIterator_Call struct {
	*mock.Call
}

// GetShardIterator is a helper method to define mock.On call
//   - ctx context.Context
//   - params *kinesis.GetShardIteratorInput
//   - optFns ...func(*kinesis.Options)
func (_e *KinesisAPI_Expecter) GetShardIterator(ctx interface{}, params interface{}, optFns ...interface{}) *KinesisAPI_GetShardIterator_Call {
	return &KinesisAPI_GetShardIterator_Call{Call: _e.mock.On("GetShardIterator",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *KinesisAPI_GetShardIterator_Call) Run(run func(ctx context.Context, params *kinesis.GetShardIteratorInput, optFns ...func(*kinesis.Options))) *KinesisAPI_GetShardIterator_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*kinesis.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*kinesis.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*kinesis.GetShardIteratorInput), variadicArgs...)
	})
	return _c
}

func (_c *KinesisAPI_GetShardIterator_Call) Return(_a0 *kinesis.GetShardIteratorOutput, _a1 error) *KinesisAPI_GetShardIterator_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *KinesisAPI_GetShardIterator_Call) RunAndReturn(run func(context.Context, *kinesis.GetShardIteratorInput, ...func(*kinesis.Options)) (*kinesis.GetShardIteratorOutput, error)) *KinesisAPI_GetShardIterator_Call {
	_c.Call.Return(run)
	return _c
}

// ListShards provides a mock function with given fields: ctx, params, optFns
func (_m *KinesisAPI) ListShards(ctx context.Context, params *kinesis.ListShardsInput, optFns ...func(*kinesis.Options)) (*kinesis.ListShardsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListShards")
	}

	var r0 *kinesis.ListShardsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.ListShardsInput, ...func(*kinesis.Options)) (*kinesis.ListShardsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.ListShardsInput, ...func(*kinesis.Options)) *kinesis.ListShardsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesis.ListShardsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesis.ListShardsInput, ...func(*kinesis.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KinesisAPI_ListShards_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListShards'
type KinesisAPI_ListShards_Call struct {
	*mock.Call
}

// ListShards is a helper method to define mock.On call
//   - ctx context.Context
//   - params *kinesis.ListShardsInput
//   - optFns ...func(*kinesis.Options)
func (_e *KinesisAPI_Expecter) ListShards(ctx interface{}, params interface{}, optFns ...interface{}) *KinesisAPI_ListShards_Call {
	return &KinesisAPI_ListShards_Call{Call: _e.mock.On("ListShards",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *KinesisAPI_ListShards_Call) Run(run func(ctx context.Context, params *kinesis.ListShardsInput, optFns ...func(*kinesis.Options))) *KinesisAPI_ListShards_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*kinesis.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*kinesis.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*kinesis.ListShardsInput), variadicArgs...)
	})
	return _c
}

func (_c *KinesisAPI_ListShards_Call) Return(_a0 *kinesis.ListShardsOutput, _a1 error) *KinesisAPI_ListShards_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *KinesisAPI_ListShards_Call) RunAndReturn(run func(context.Context, *kinesis.ListShardsInput, ...func(*kinesis.Options)) (*kinesis.ListShardsOutput, error)) *KinesisAPI_ListShards_Call {
	_c.Call.Return(run)
	return _c
}

// PutRecords provides a mock function with given fields: ctx, params, optFns
func (_m *KinesisAPI) PutRecords(ctx context.Context, params *kinesis.PutRecordsInput, optFns ...func(*kinesis.Options)) (*kinesis.PutRecordsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutRecords")
	}

	var r0 *kinesis.PutRecordsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.PutRecordsInput, ...func(*kinesis.Options)) (*kinesis.PutRecordsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *kinesis.PutRecordsInput, ...func(*kinesis.Options)) *kinesis.PutRecordsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kinesis.PutRecordsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *kinesis.PutRecordsInput, ...func(*kinesis.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KinesisAPI_PutRecords_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PutRecords'
type KinesisAPI_PutRecords_Call struct {
	*mock.Call
}

// PutRecords is a helper method to define mock.On call
//   - ctx context.Context
//   - params *kinesis.PutRecordsInput
//   - optFns ...func(*kinesis.Options)
func (_e *KinesisAPI_Expecter) PutRecords(ctx interface{}, params interface{}, optFns ...interface{}) *KinesisAPI_PutRecords_Call {
	return &KinesisAPI_PutRecords_Call{Call: _e.mock.On("PutRecords",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *KinesisAPI_PutRecords_Call) Run(run func(ctx context.Context, params *kinesis.PutRecordsInput, optFns ...func(*kinesis.Options))) *KinesisAPI_PutRecords_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*kinesis.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*kinesis.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*kinesis.PutRecordsInput), variadicArgs...)
	})
	return _c
}

func (_c *KinesisAPI_PutRecords_Call) Return(_a0 *kinesis.PutRecordsOutput, _a1 error) *KinesisAPI_PutRecords_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *KinesisAPI_PutRecords_Call) RunAndReturn(run func(context.Context, *kinesis.PutRecordsInput, ...func(*kinesis.Options)) (*kinesis.PutRecordsOutput, error)) *KinesisAPI_PutRecords_Call {
	_c.Call.Return(run)
	return _c
}

// NewKinesisAPI creates a new instance of KinesisAPI. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewKinesisAPI(t interface {
	mock.TestingT
	Cleanup(func())
}) *KinesisAPI {
	mock := &KinesisAPI{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
